""""
    Генераторы в Python
    
    При использовании return после завершения работы функции  управление передается
вызвавшему ее оператору, а состояние функции при этом не сохранятеся. При след. вызофе
функции, она будет отрабатывать заново от начала до конца.
    
    Существует спец. функция-генератор, возвращающая объект, а не значение. При этом
она сохраняет состояние своего последнего вызова и при след. вызоые продолжает работу
с той же точки.
    Функции-генераторы определяются по аналогии с обычными функициями, но дополнительно
содержат генераторную "инсрукцию", начинающуюся со слова yield и определяетобъек-генератор,
который возвращается оператору, вызвавшему функцию.
    Когда генераторная функция исполняется, состояние объекта-генератора "замораживается"
и сохраняется, объект может быть присвоен переменной. С помощью встроенной функции next()
можно, передав ей имя этой переменной, продолжить выполнение функции с той самой точки
заморозки.
    Повторный вызов генератора с помощью next() продолжает исполнение функции до тех пор,
пока не вызовется исключение. Его можно избежать поместив генераторную инструкцию внутрь
бесконечного цикла.
    Пример:
        чтобы сгенерировать значение с приращением на каждом новом вызове, запишем:
    def incrementer()
        i=1
        while True :
            yield i
            i+=1
            inc=incrementer()
        print (next(inc))
        print (next(inc))
        print (next(inc))
    Эти последовательные вызовы функции выведут 1, 2 и 3
    При изменении условного выражения в данном цикле на while < 3 третий вызов функции
приведет к генерации исключения StopIteration.
    Наиболее эффективно размещать объект-генератор в цикле, осуществляющем последовательные
итерации по значениям.
"""""


# Задания:
# 1. Определить функцию, которая начинается с инициализации двух переменных одним целым числом

def fibonacci_generator():
    a = b = 1

    # 2. Добавить бесконечный цикл (не забыть про отступ) для генерации суммы двух предыдущих значений

    while True:
        yield a
        a, b = b, a + b


# 3. Присвоить переменной возвращенный объект-генератор

fib = fibonacci_generator()

# 4. Добавить цикл для последовательного вызова функции-генератора и вывода ее значения на каждой
# итерации.

for i in fib:
    if i > 1000:
        break
    else:
        print('Generated:', i)

""""
    Для проверки, является ли объект генератором, можно использовать функцию type()
"""""